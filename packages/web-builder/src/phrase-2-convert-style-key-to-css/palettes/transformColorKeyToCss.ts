import { type ColorKeys, CssColorProperty, InteractionStateCssMapping } from '@kiskadee/schema';
import { convertHslaToHex } from '../utils/convertHslaToHex';

/**
 * Transforms a key generated by convertPalettesToKeys into a CSS rule.
 */
export function transformColorKeyToCss(key: string): string {
  const valueRegex = /\[([^\]]+)]$/;
  const valueMatch = key.match(valueRegex);
  if (!valueMatch) {
    throw new Error('Invalid key format. Expected value in square brackets at the end.');
  }

  const hsla = valueMatch[1].split(',').map((v) => Number.parseFloat(v)) as [
    number,
    number,
    number,
    number
  ];
  const hexColor = convertHslaToHex(hsla);

  const colorKey = key.split(/--|__/)[0] as ColorKeys;
  const cssProperty = CssColorProperty[colorKey];

  if (!key.includes('::ref')) {
    return `.${key} { ${cssProperty}: ${hexColor}; }`;
  }

  // Build a regex from the values of InteractionStateCssMapping (strip leading ':')
  const validStates = Object.values(InteractionStateCssMapping)
    .map((val) => val.replace(/^:/, ''))
    .join('|');
  const [refSelector] = key.split('__');
  const stateRegex = new RegExp(`--(${validStates})(?=::ref)`);
  const stateMatch = refSelector.match(stateRegex);
  if (!stateMatch) {
    throw new Error('Invalid key format. "::ref" requires a preceding interaction state.');
  }

  const parentSelector = `.${key}:${stateMatch[1]}`;
  return `${parentSelector} .${refSelector} { ${cssProperty}: ${hexColor}; }`;
}
