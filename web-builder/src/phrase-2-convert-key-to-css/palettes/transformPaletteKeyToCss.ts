import { type ColorKeys, CssColorProperty } from '@kiskadee/schema';

/*
  Map of color keys to valid CSS property names.
*/
const cssPropertyMap: Record<ColorKeys, CssColorProperty> = {
  textColor: CssColorProperty.textColor,
  bgColor: CssColorProperty.bgColor,
  borderColor: CssColorProperty.borderColor
};

/**
 * Converts an HSLA array into a hexadecimal color string.
 * - h: hue in degrees (0-360)
 * - s and l: saturation and lightness as percentages (0-100)
 * - a: alpha (0-1)
 *
 * Returns a 6-digit hex if alpha is 1, otherwise an 8-digit hex (including alpha).
 */
function convertHslaToHex(hsla: [number, number, number, number]): string {
  let [h, s, l, a] = hsla;
  s /= 100;
  l /= 100;

  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
  const m = l - c / 2;
  let r = 0;
  let g = 0;
  let b = 0;

  if (h >= 0 && h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h >= 60 && h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h >= 120 && h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h >= 180 && h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h >= 240 && h < 300) {
    r = x;
    g = 0;
    b = c;
  } else if (h >= 300 && h < 360) {
    r = c;
    g = 0;
    b = x;
  }

  const toHex = (n: number) => {
    const hex = Math.round((n + m) * 255).toString(16);
    return hex.padStart(2, '0');
  };

  const rHex = toHex(r);
  const gHex = toHex(g);
  const bHex = toHex(b);

  // If alpha is 1 or undefined, return a 6-digit hex code.
  if (a === undefined || a === 1) {
    return `#${rHex}${gHex}${bHex}`;
  }
  const aHex = Math.round(a * 255)
    .toString(16)
    .padStart(2, '0');
  return `#${rHex}${gHex}${bHex}${aHex}`;
}

/**
 * Transforms a key generated by convertPalettesToKeys into a CSS rule.
 *
 * Rules:
 * - If the key does NOT contain "::ref", output is:
 *
 *     .[key] {
 *       [cssProperty]: <hex-converted-color>;
 *     }
 *
 * - If the key contains "::ref", output is two selectors:
 *
 *     .[fullKey] .[refSelector] {
 *       [cssProperty]: <hex-converted-color>;
 *     }
 *
 * The CSS property is determined from the palette key using the cssPropertyMap.
 */
export function transformColorKeyToCss(key: string): string {
  // Regular expression to capture the value in square brackets at the end of the string
  const valueRegex = /\[([^\]]+)\]$/;
  const valueMatch = key.match(valueRegex);

  if (!valueMatch) {
    throw new Error('Invalid key format. Expected value in square brackets at the end.');
  }

  // Extract the raw color value (e.g., "[120,50,50,1]") and then extract the numeric values
  const valueStr = valueMatch[1];
  const hsla = valueStr.split(',').map((v) => Number.parseFloat(v)) as [
    number,
    number,
    number,
    number
  ];

  // Convert HSLA value to hexadecimal color
  const hexColor = convertHslaToHex(hsla);

  // Determine the palette key (e.g., "textColor") that maps to a CSS property.
  // Splits on "--" or "__" to get the palette property.
  const colorKey = key.split(/--|__/)[0];
  const cssProperty = cssPropertyMap[colorKey as ColorKeys];

  const hasRef = key.includes('::ref');
  let cssRule = '';

  if (hasRef) {
    // When the key includes "::ref", the referential selector is the key without the "__[value]" part.
    const [refSelector] = key.split('__');
    cssRule = `.${key} .${refSelector} { ${cssProperty}: ${hexColor}; }`;
  } else {
    cssRule = `.${key} { ${cssProperty}: ${hexColor}; }`;
  }

  return cssRule;
}

/* Examples */

// Example 1:
const cssRule1 = transformColorKeyToCss('textColor__[120,50,50,1]');
console.log(cssRule1);
// Expected output (color converted to hex):
// .textColor__[120,50,50,1] {
//   color: <hex equivalent>;
// }

// Example 2:
const cssRule2 = transformColorKeyToCss('bgColor--hover::ref__[240,50,50,0.5]');
console.log(cssRule2);
// Expected output (color converted to hex):
// .textColor--hover::ref__[240,50,50,0.5] .textColor--hover::ref {
//   color: <hex equivalent>;
// }
