import { type ColorKeys, CssColorProperty } from '@kiskadee/schema';
import { convertHslaToHex } from '../utils/convertHslaToHex';

/**
 * Transforms a key generated by convertPalettesToKeys into a CSS rule.
 *
 * Rules:
 * - If the key does NOT contain "::ref", output is:
 *
 *     .[key] {
 *       [cssProperty]: <hex-converted-color>;
 *     }
 *
 * - If the key contains "::ref", output is two selectors:
 *
 *     .[fullKey] .[refSelector] {
 *       [cssProperty]: <hex-converted-color>;
 *     }
 *
 * The CSS property is determined from the palette key using the cssPropertyMap.
 */
export function transformColorKeyToCss(key: string): string {
  // Regular expression to capture the value in square brackets at the end of the string
  const valueRegex = /\[([^\]]+)]$/;
  const valueMatch = key.match(valueRegex);

  if (!valueMatch) {
    throw new Error('Invalid key format. Expected value in square brackets at the end.');
  }

  // Extract the raw color value (e.g., "[120,50,50,1]") and then extract the numeric values
  const valueStr = valueMatch[1];
  const hsla = valueStr.split(',').map((v) => Number.parseFloat(v)) as [
    number,
    number,
    number,
    number
  ];

  // Convert HSLA value to hexadecimal color
  const hexColor = convertHslaToHex(hsla);

  // Determine the palette key (e.g., "textColor") that maps to a CSS property.
  // Splits on "--" or "__" to get the palette property.
  const colorKey = key.split(/--|__/)[0];
  const cssProperty = CssColorProperty[colorKey as ColorKeys];

  const hasRef = key.includes('::ref');
  let cssRule = '';

  if (hasRef) {
    // When the key includes "::ref", the referential selector is the key without the "__[value]" part.
    const [refSelector] = key.split('__');
    cssRule = `.${key} .${refSelector} { ${cssProperty}: ${hexColor}; }`;
  } else {
    cssRule = `.${key} { ${cssProperty}: ${hexColor}; }`;
  }

  return cssRule;
}
